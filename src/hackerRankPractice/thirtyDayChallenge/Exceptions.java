package hackerRankPractice.thirtyDayChallenge;

/*



*/

public class Exceptions {
}

/*

STRING TO INTEGER

Many languages offer some functionality for parsing an integer value from a string token.

Each of these functions will raise an error (i.e.: throw an exception) when the argument
passed as the token parameter cannot be converted to an integer. Most languages have built-in
exception handling methods such as try-catch or begin-rescue that enable you to code
specific behaviors to handle execution issues.

EXCEPTIONS

If your code attempts to perform an action that cannot be completed,
the flow of control is halted and an exception is thrown. This means
that an Exception object is created as a response to this unusual condition.
The control flow is then transferred (or handed off) to an exception handler.
By anticipating and writing handlers for exceptional conditions in your
program's logic, you can resolve the issue that raised the exception and
your program can continue executing. A program "crash" is generally the
result of an unhandled exception.

Exception handling is expensive, meaning it takes a lot of behind-the-scenes work for your
program to stop everything and figure out how an exceptional scenario should be handled.
Under normal circumstances, you can avoid the need to handle many kinds of exceptions by
anticipating and coding for all possible scenarios.

MANAGING EXCEPTIONS: TRY

The try block is like a staging area for potentially error-raising code. If your program is unable to execute the code inside a try block, it throws an exception and tries to find an exception handler to salvage the situation. The syntax is as follows:

try{
    // write exception-throwing code here
}

MANAGING EXCEPTIONS: CATCH

MANAGING EXCEPTIONS: FINALLY

MANAGING EXCEPTIONS: TRY WITH RESOURCES

*/


























